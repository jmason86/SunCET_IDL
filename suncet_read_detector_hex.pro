;+
; NAME:
;  SunCET_read_detector_hex
;
; PURPOSE:
;   Converts a hex file generated by SunCET detector to a 2D long integer array
;
; INPUTS:
;   path_filename [string]: The path and filename of the .hex to read
;
; OPTIONAL INPUTS:
;   nrows [long]: The number of rows in the image you're trying to read. Default is 1500. 
;   ncols [long]: The number of columns in the image you're trying to read. Default is 1500. 
;
; KEYWORD PARAMETERS:
;   None
;
; OUTPUTS:
;   img [lonarr]: Resultant 2D image array: lonarr(ncols, nrows)
;
; OPTIONAL OUTPUTS:
;   None
;
; RESTRICTIONS:
;   None
;
; EXAMPLE:
;   im = SunCET_read_detector_hex(path_filename, nrows=1504, ncols=2000)
;-
FUNCTION SunCET_read_detector_hex, path_filename, $
                                   nrows=nrows, ncols=ncols

; Defaults
IF nrows EQ !NULL THEN BEGIN
  nrows = 1500L
ENDIF
IF ncols EQ !NULL THEN BEGIN
  ncols = 1500L
ENDIF

; Input check
IF NOT isA(nrows, 'long') OR NOT isA(ncols, 'long') THEN BEGIN
  message, /INFO, 'Input nrows and ncols must be long integer type'
  return, -1
ENDIF

; Read binary into byte array
get_lun, lun
openr, lun, path_filename
B = bytarr(2, nrows*ncols, /NOZERO)
readu, lun, b
close, lun
free_lun, lun

; Uhhhh... do something? Not sure what this is for
c = dblarr(nrows*ncols)
c = reform(b[0, *] + 256 * b[1, *])

; Form into 2D long array
img = lonarr(nrows, ncols)
FOR j = 0l, ncols - 1 DO BEGIN
  img[*, j] = c[j * nrows:j * nrows + (nrows - 1)]
ENDFOR

; Not totally sure.. but appears to be handling roll over on saturated pixels
satpx = where(img LT 0, cnt)
IF cnt GT 0 THEN BEGIN
  img[satpx] += 65535L
ENDIF

; Rotate the image to be consistent with what is shown in MATLAB
img = rotate(img, 3)

return, img

END
